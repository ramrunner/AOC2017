(import srfi-69)
(import format)
(import queues)
(import (chicken io))
(import (chicken string))
(import (chicken file posix))

(define make-vm-queue
  (lambda ()
    (let* ((store (make-queue))
           (put (lambda (e)
                  (queue-add! store e)))
           (get (lambda ()
                  (if (queue-empty? store)
                      '()
                      (queue-remove! store))))
           (len (lambda ()
                  (queue-length store)))
           (dispatch (lambda (m)
                       (cond ((eq? m 'put) put)
                             ((eq? m 'print) (display (queue->list store)))
                             ((eq? m 'len) len)
                             ((eq? m 'get) get)))))
       dispatch)))
    
(define duetvm
  (lambda (id)
    (let* ((regs (make-hash-table))
           (ip 0)
           (step 0)
           (terminated #f)
           (vm-text '())
           (queue (make-vm-queue))
           (neighbour #f)
           (sendcnt 0)
           (jumpflag #f)
           (blockflag #f)
           (gr (lambda (reg) ;; get register
                 (hash-table-ref/default regs reg 0)))
           (val-reg (lambda (v) (if (eq? (string->number v) #f) (gr v) (string->number v))))
           (vm-set (lambda (reg val)
                     (hash-table-set! regs reg (val-reg val))))
           (vm-mul (lambda (reg val)
                     (hash-table-set! regs reg (* (gr reg) (val-reg val)))))
           (vm-jqz (lambda (reg y) (if (> (val-reg reg) 0) (begin (set! ip (+ ip (val-reg y))) (set! jumpflag #t)))))
           (vm-mod (lambda (reg val) (hash-table-set! regs reg (remainder (val-reg reg) (val-reg val)))))
	   (vm-add (lambda (reg val) (hash-table-set! regs reg (+ (val-reg reg) (val-reg val)))))
           (vm-snd (lambda (reg) (hash-table-set! regs "snd" (gr reg))))
           (vm-snd2 (lambda (reg)
                      (begin
                       (set! sendcnt (+ 1 sendcnt))
                       ((queue 'put) (val-reg reg))
                       (format #t "~A sent ~A .totsent ~A qsize:~A ~%" id (val-reg reg) sendcnt ((queue 'len)))
                       ((neighbour 'unblock)))))
           (vm-rcv (lambda (reg) (if (not (= (gr reg) 0)) (begin (format #t "RES: ~A" (gr "snd")) (sleep 2) (gr "snd")))))
           (vm-rcv2 (lambda (reg)
                      (let ((nelem ((((neighbour 'get-queue)) 'get))))
                        (if (null? nelem)
                            (begin (format #t "~A blocking~%" id) (set! blockflag #t))
                            (begin (format #t "~A received ~A~%" id nelem) (set! blockflag #f) (hash-table-set! regs reg nelem))))))
           (vm-test (lambda (a b) (format #t "test caled! a ~A b ~A regs:~A ~%" a b (hash-table->alist regs))))
           (vm-do (lambda (op)
                    (cond ((string=? op "set") vm-set)
                          ((string=? op "mul") vm-mul)
		          ((string=? op "add") vm-add)
                          ((string=? op "jgz") vm-jqz)
                          ((string=? op "mod") vm-mod)
                          ((string=? op "rcv") vm-rcv2)
                          ((string=? op "test") vm-test)
                          ((string=? op "snd") vm-snd2)
                          (else (error "vm-do unknown op")))))
           (vm-load (lambda (fname)
                      (hash-table-set! regs "p" id) ;;capture id to the p register
                      (with-input-from-file fname
                                            (lambda ()
                                              (letrec ((loop (lambda ()
                                                               (let ((line (read-line)))
                                                                 (if (not (eof-object? line))
                                                                     (begin 
                                                                       (set! vm-text (append vm-text (list line)))
                                                                       (loop)))))))
                                                (loop))))))
           (vm-run (lambda ()
                     (letrec* ((textlen (length vm-text))
                               (loop (lambda ()
                                       (cond ((eq? terminated #t) 'EXECTERMINATED)
                                              ((or (< ip 0) (>= ip textlen)) (begin (format #t "~A terminating~%" id) (set! terminated #t) 'EXECTERMINATED))
                                              ((eq? blockflag #t) (format #t "~A blocked totsent:~A ~%" id sendcnt))
                                              (else
                                               (begin
                                                 (format #t "id:~A iteration ~A ip:~A instruction:~A~%" id step ip (list-ref vm-text ip))
                                                 (let* ((args (string-split (list-ref vm-text ip) " "))
                                                        (len (length args)))
                                                   (if (= len 3)
                                                       ((vm-do (car args)) (cadr args) (caddr args))
                                                       ((vm-do (car args)) (cadr args)))
                                                       ;(if (eq? (string->number (cadr args)) #f)
                                                       ;    ((vm-do (car args)) (gr (cadr args)))
                                                       ;    ((vm-do (car args)) (cadr args)))))
                                                 (call/cc (lambda (ret)
                                                   (if (eq? blockflag #t) ;; we got blocked. don't advance
                                                       (ret 'BLOCKED))
                                                   (if (eq? jumpflag #t)
                                                        (set! jumpflag #f) ;; if we jumped the ip should be this guy
                                                        (set! ip (+ ip 1))) ;; advance ip otherwise
                                                   (set! step (+ 1 step)) ;;))))))
                                                   (ret (loop)))))))))))
                       (loop))))
           (vm-dump (lambda () (format #t "id:~A term?:~A blocked?:~A~% numcode:~A text:~A~%ip:~A~%regs:~A~%totsent:~A~%" id terminated blockflag (length vm-text) vm-text ip (hash-table->alist regs) sendcnt)))
           (vm-blocked? (lambda () blockflag))
           (vm-term? (lambda () terminated))
           (vm-unblock (lambda () (if (eq? blockflag #t) (begin (format #t "~A unblocking ~%" id) (set! blockflag #f)))))
           (vm-queue (lambda () queue))
           (set-neighbour (lambda (n) (set! neighbour n)))
           (dispatch (lambda (m)
                       (cond ((eq? m 'do) vm-do)
                             ((eq? m 'load) vm-load)
                             ((eq? m 'dump) vm-dump)
                             ((eq? m 'unblock) vm-unblock)
                             ((eq? m 'set-neighbour) set-neighbour)
                             ((eq? m 'blocked?) vm-blocked?)
                             ((eq? m 'terminated?) vm-term?)
                             ((eq? m 'get-queue) vm-queue)
                             ((eq? m 'run) vm-run)))))
      dispatch)))

(define dvm1 (duetvm 0))
(define dvm2 (duetvm 1))
((dvm1 'load) "inputs/day18")
((dvm2 'load) "inputs/day18")
((dvm1 'set-neighbour) dvm2)
((dvm2 'set-neighbour) dvm1)

(define (round-robin vm1 vm2)
  (cond ((or ((vm1 'terminated?)) ((vm2 'terminated?)) (and ((vm1 'blocked?)) ((vm2 'blocked?)))) 'END)
        (else 
         (begin 
           ((vm1 'run)) 
           ((vm2 'run)) 
           ;(format #t "vm1q:~A~%" (((vm1 'get-queue)) 'print))
           ;(format #t "vm2q:~A~%" (((vm2 'get-queue)) 'print))
           (round-robin vm1 vm2)))))

(round-robin dvm1 dvm2)
((dvm1 'dump))
((dvm2 'dump))
