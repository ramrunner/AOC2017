(use regex)
(use srfi-69)
(use srfi-1)
(use data-structures)
(define points '())

(define (make-vec x y z)
  (list x y z))

(define (make-point q v a num)
  (list q v a num))

(define (tokey v) (sprintf "~A,~A,~A" (vec-x v) (vec-y v) (vec-z v)))
(define (point-pos p) (list-ref p 0))
(define (point-vec p) (list-ref p 1))
(define (point-acc p) (list-ref p 2))
(define (point-num p) (list-ref p 3))
(define (vec-x v) (list-ref v 0))
(define (vec-y v) (list-ref v 1))
(define (vec-z v) (list-ref v 2))

#| wrong function for part2 !!!! it doesn't update at the right order.
(define (move p)
  (let ((x (point-pos p))
        (v (point-vec p))
        (a (point-acc p)))
  (make-point (make-vec (+ (vec-x x) (vec-x v))
                        (+ (vec-y x) (vec-y v))
                        (+ (vec-z x) (vec-z v)))
              (make-vec (+ (vec-x v) (vec-x a))
                        (+ (vec-y v) (vec-y a))
                        (+ (vec-z v) (vec-z a)))
              a
              (point-num p))))
|#

(define (move2 p)
  (let* ((x (point-pos p))
         (v (point-vec p))
         (a (point-acc p))
         (nxv (+ (vec-x v) (vec-x a)))
         (nyv (+ (vec-y v) (vec-y a)))
         (nzv (+ (vec-z v) (vec-z a)))
         (nxx (+ (vec-x x) nxv))
         (nyx (+ (vec-y x) nyv))
         (nzx (+ (vec-z x) nzv)))
    (make-point (make-vec nxx nyx nzx)
                (make-vec nxv nyv nzv)
                a
                (point-num p))))

(define (manhattan q)
  (+ (abs (vec-x q)) (abs (vec-y q)) (abs (vec-z q))))

(define pmaps (make-hash-table))

(define (sim simpoints steps)
  (letrec ((loop (lambda (step spoints)
                   (let ((todelete '()))
                     (if (< step steps)
                         (begin
			   (for-each (lambda (p) 
                                         (if (hash-table-exists? pmaps (tokey (point-pos p)))
                                             (begin 
                                               (format #t "found collision!~%")
                                               (set! todelete (append todelete (list (point-num p) (hash-table-ref pmaps (tokey (point-pos p)))))))
                                             (hash-table-set! pmaps (tokey (point-pos p)) (point-num p))))
                                       spoints)
                         (format #t "having ~A deleting ~A~%" (length spoints) (length todelete))
                         (hash-table-clear! pmaps)
                         (loop (+ 1 step) (map move2 (filter (lambda (e) (eq? #f (memq (point-num e) todelete))) spoints))))
                         spoints)))))
    (loop 0 simpoints)))

(define (do-test its)
  (let* ((fpoints (sim points its))
         (epoints (sort fpoints (lambda (a b) (< (manhattan (point-pos a)) (manhattan (point-pos b)))))))
    (format #t "closest:~A farthest:~A" (car epoints) (list-ref epoints (- (length epoints) 1)))))


(define (parse fname)
  (with-input-from-file fname
                        (lambda ()
                          (letrec ((loop (lambda (line num)
                                           (if (eof-object? line)
                                               '()
                                               (let ((p (string-split-fields "\\w+|-\\w+" line)))
                                                 (set! points (cons (make-point (make-vec (string->number (list-ref p 1))
                                                                                          (string->number (list-ref p 2))
                                                                                          (string->number (list-ref p 3)))
                                                                                (make-vec (string->number (list-ref p 5))
                                                                                          (string->number (list-ref p 6))
                                                                                          (string->number (list-ref p 7)))
                                                                                (make-vec (string->number (list-ref p 9))
                                                                                          (string->number (list-ref p 10))
                                                                                          (string->number (list-ref p 11)))
                                                                                num)
                                                                                points))
                                                 (loop (read-line) (+ num 1)))))))
                            (loop (read-line) 0)))))
