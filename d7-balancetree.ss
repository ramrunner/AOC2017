(use srfi-69)
(use data-structures)

;to find the root just pick a node and run (findloop "node")
;to find the suspect run with (iterateToSuspect "ROOT" 0 '() 0)

(define childrenparent (make-hash-table))
(define parentchildren (make-hash-table))
(define allnodes (make-hash-table))


(define (addchild parent child)
  (let ((record (if (hash-table-exists? parentchildren parent) (hash-table-ref parentchildren parent) #f)))
    (if (eq? record #f)
      (hash-table-set! parentchildren parent (list child))
      (hash-table-set! parentchildren parent (append record (list child))))))
(define readinput
  (lambda (fname)
   (map (lambda (ln)
     (let ((sparts (string-split ln "->"))) 
       (if (eq? (length sparts) 1)
         (let* ((pparts (string-split (car sparts)))
               (weight (string-split (cadr pparts) "()")))
              (hash-table-set! allnodes (car pparts) (string->number (car weight))))
         (let* ((cparts (string-split (cadr sparts) ", "))
               (pparts (string-split (car sparts)))
                (weight (string-split (cadr pparts) "()")))
           (format #t "dad:~A kids:~A~%" (car sparts) cparts)
           (hash-table-set!  allnodes (car pparts) (string->number (car weight)))
           (map (lambda (e) (format #t "storing ~A under key ~A~%" (car pparts) e) (addchild (car pparts) e) (hash-table-set! childrenparent  e (car pparts))) cparts)))))
         (read-lines fname))))

(define findloop (lambda (parent)
    (if (hash-table-exists? childrenparent parent)
      (findloop (hash-table-ref childrenparent parent))
      parent)))

(define (treetraverse node)
  (let ((children (if (hash-table-exists? parentchildren node)
                      (hash-table-ref parentchildren node)
                      #f)))
  (if (not (eq? children #f))
      (foldr + (hash-table-ref allnodes node) (map (lambda (e) (treetraverse e)) children))
      (hash-table-ref allnodes node))))

(define (iterateToSuspect from initw prevlvl suspind)
  (let* ((myweight (hash-table-ref allnodes from))
        (weightfromme (treetraverse from))
        (children (hash-table-ref parentchildren from))
        (childrenw (map treetraverse children))
        (allchildrenweight (foldr + 0 childrenw))
        (shouldweight (floor (/ allchildrenweight (length children)))))
  (format #t "on this level ~A each child should hold ~A~%" from shouldweight)
  (format #t "their weights:~A ~A ~%" childrenw children)
  (let ((suspect (foldr (lambda (e suspectind) 
                          (if (eq? (car suspectind) #f)
                              (cons (eq? e shouldweight) (+ 1 (cdr suspectind)))
                               suspectind)) (cons #f -1) childrenw))
         (suspectind (abs (- (- (length children) 1) (cdr (foldr (lambda (e suspectind) 
           (if (eq? (car suspectind) #f)
               (cons (eq? e shouldweight) (+ 1 (cdr suspectind)))
               suspectind)) (cons #f -1) childrenw))))))
     (if (or (>= suspectind (length children)) (< suspectind 0) (eq? (car suspect) #t))
         (format #t "the suspect is ~A his weight is ~A ~%" (list-ref prevlvl suspind) (hash-table-ref allnodes (list-ref prevlvl suspind)))
         (begin (format #t "reiterating with suspect ~A~%" suspect) (iterateToSuspect (list-ref children suspectind) shouldweight children suspectind))))))
